\chapter{Il package Checkers}
Il \emph{package} \texttt{it.polito.Checkers} racchiude un insieme di
classi in grado di gestire una partita a Dama.\\ 
Il motore del gioco è racchiuso nella classe \texttt{Engine}, mentre le altre
classi fungono da interfaccia verso il resto del progetto.\\
Il motivo di questa organizzazione è dato dal fatto che tutti i metodi di
\texttt{Engine} provengono da una Java applet sviluppata da un gruppo di studenti
del \emph{California Institute of Technology} (http://www.cs.caltech.edu).
Essendo questo codice poco orientato ad oggetti e per la quasi totalità
costituito da metodi statici, è stato racchiuso in una sola classe i cui metodi
vengono richiamati dagli oggetti \emph{wrapper} che la circondano.\\
la scelta di impiegare codice già pronto in questa parte è stata
mutuata essenzialmente dai limiti temporali (anche se non nascondiamo che in più
occasioni avremmo preferito riscriverlo da zero!) nonché dal fatto che
implementare l'intera intelligenza per il gioco della dama avrebbe esulato dalla
natura del progetto stesso.
\section{Engine}
Il cuore della classe è costituito dai metodi \texttt{MiniMax()},
\texttt{Evaluate()} e \texttt{generate\\\_moves()}. Tutti gli altri metodi
servono a fornire supporto a questi tre.\\
Tra essi \texttt{generate\_moves()} è quello più complicato, perchè si occupa di
creare il vettore delle mosse possibili per un determinato giocatore, data una
qualsiasi configurazione (purchè valida) delle pedine sulla scacchiera.
Pertanto si serve di una serie di altre funzioni che, sostanzialmente,
determinano quali mosse, tra tutte quelle possibili, sono effettivamente valide
secondo le regole della Dama.
\subsection{MiniMax}
Nella teoria dei giochi un algoritmo si definisce di tipo \emph{MiniMax}, se è
finalizzato a \emph{mini}mizzare la \emph{massima} perdita possibile.\\
In un gioco a turni, come la Dama, l'algoritmo si esprime in modo ricorsivo
come segue:
\lstset{tabsize=2}
\begin{lstlisting}
function minimax(node, depth)
	IF is_terminal(node) OR depth = 0
		return Evaluate(Nodo)
	IF turn = opponent
		alpha := +inf
		FOREACH child of node
			alpha := min(alpha, minimax(child, depth-1))
	ELSE {our turn}
		alpha := -inf
		FOREACH child of node
			alpha := max(alpha, minimax(child, depth-1))
	return alpha
\end{lstlisting}
Dato l'albero delle mosse possibili e data una profondità massima di
ricorsione, si simula l'esecuzione della mossa che minimizza il valore della
migliore posizione raggiungibile dall'altro giocatore. Quindi l'algoritmo assegna
un valore ad ogni mossa legale, proporzionale a quanto essa diminuisce il valore della
posizione per l'altro giocatore.\\
La funzione \texttt{Evaluate} è fondamentale per valutare, ad ogni passo, la
bontà di quel determinato stato del gioco (i.e. quanto sia desiderabile per il
dato giocatore raggiungere quella posizione). Se un nodo è terminale (mossa
vincente) \texttt{MiniMax} deve ritornare $\pm\infty$ a seconda che il
turno corrente sia rispettivamente del primo o del secondo giocatore.
Altrimenti significa che si è raggiunto il limite di profondità prefissato. In questo caso
\texttt{Evaluate} effettuerà una stima delle pedine in gioco assegnando un peso
ad ognuna di esse in funzione della loro posizione e del loro valore (ad
esempio, una dama vale di più di una normale pedina).\\
Ovviamente, se si fissasse una profondità di ricorsione pari a infinito, non
sarebbe necessaria la stima euristica data da \texttt{Evaluate} e si
determinerebbe ad ogni passo una mossa ottima; è altrettanto chiaro tuttavia che
questa strategia è applicabile unicamente in giochi estremamente banali (ad
esempio il Tris), in quanto il numero di nodi da valutare cresce
esponenzialmente con la profondità di ricerca ed è pari\footnote{Più
precisamente il \texttt{MiniMax} incluso nel progetto è ottimizzato mediante
potatura alpha-beta dell'albero delle decisioni (si rimanda a letteratura
specifica per eventuali approfondimenti) che riduce la complessità a
$O\left(\sqrt{\overline{m}^d}\right)$ nel caso migliore} a $O(\overline{m}^d)$
(dove $\overline{m}$ è il numero medio di mosse possibili e $d$ è la profondità)
determinando una complessità finale di tipo NP completo.

\section{Square}
Rappresenta una casella sulla scacchiera. Mantiene semplicemente due attributi
interi che rappresentano le coordinate della casella.\\
I metodi contenuti in \texttt{Engine} non usano questo tipo di astrazione, ma
tipicamente mantengono separate le coordinate; la conversione in oggetti
\texttt{Square} viene eseguita dalle classi \texttt{Move} e \texttt{Board}

\section{Move e MoveCollection}
Le classi Move e MoveCollection sono state implementate per permettere una
gestione orientata agli oggetti delle mosse restituite dalla classe 
\texttt{Engine}.

\paragraph{Classe Move} 
Si occupa principalmente di rimappare a livello di oggetto la
singola mossa generata dalla classe \texttt{Engine}, questa astrazione viene
implementata dai metodi \texttt{toArray()}, che fa il mapping da oggetto a
vettore di interi, e \texttt{fromArray()}, che si occupa di convertire le mosse
da vettore ad oggetto.\\
La classe \texttt{Move} mantiene l'informazione sulle mosse in un attributo di
tipo \texttt{Square} contenente la casella di partenza, e in un vettore di
\texttt{Square} contenente tutte le destinazioni (in caso di prese
multiple vi sono memorizzati tutti i salti intermedi).

\paragraph{Classe MoveCollection} 
Rappresenta l'albero di tutte le destinazioni raggiungibili da una casella.
Viene utilizzata durante il controllo delle mosse fatte da \texttt{HumanPlayer}.

\section{Board}
\'E la rappresentazione della scacchiera all'interno del bricco. La classe
contiene, oltre alla posione attuale delle pedine, una collezione di
\texttt{MoveCollection} in cui sono incluse tutte le possibili mosse effettuabili dall'avversario.
Queste possono essere prelevate con il metodo \texttt{getPossibleMoves()} che
le restituisce sotto forma di \texttt{Vector<MovesCollections>}, oppure, se si necessita delle caselle di
partenza e di arrivo separatamente, sono disponibili i metodi
\texttt{getPossibleMoveFrom()} e \texttt{getPossibleMoveTo()}.\\
Quando si esegue una chiamata a \texttt{getPossibleMoves()}, il vettore
delle mosse possibili viene memorizzato in un attributo interno a
\texttt{Board}. In questo modo il vettore può essere scandito implicitamente
mediante il metodo \texttt{getPossibleMoveFrom()}, che restituisce una per
volta, ad ogni chiamata, le caselle di partenza delle mosse possibili.\\
L'indice relativo all'ultima casella restituita da
\texttt{getPossibleMoveFrom()} viene anch'esso memorizzato in un attributo di
\texttt{Board}, per cui - una volta individuata la casella di partenza - si può
procedere in modo analogo alla scansione delle possibili caselle di
destinazione, servendosi del metodo \texttt{getPossibleMoveTo()}.\\
L'ordine con cui viene scandito il vettore delle mosse possibili dipende dal
lato della scacchiera su cui si trovava il braccio all'inizio della scansione.
Questo per velocizzare l'intera operazione.




