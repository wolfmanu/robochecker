\chapter{Il package Navigation}
Il \emph{package} \texttt{it.polito.Navigation} contiene le classi deputate a gestire i movimenti del Robot sulla scacchiera.\\
In particolare sono stati progettati due controllori: \texttt{CheckersNavigator} e\\ \texttt{ArmController} che sono responsabili rispettivamente della navigazione nelle due direzioni orizzontali e in quella verticale.\\
Di seguito si entrerà nel dettaglio delle implementazioni delle classi sopra citate e dei relativi helper.
\section{La classe LashMotor}
I motori del NXT dispongono di un tachimetro incorporato, pertanto le API di
\emph{Lejos} mettono a disposizione una classe \texttt{Motor} che consente di
controllarli con una buona precisione. In particolare, mediante i metodi
\texttt{rotate()} e \texttt{rotateTo()}, è possibile ruotare il rotore di un
angolo arbitrario con un'incertezza di più o meno 2 gradi.\\
Per come sono stati impiegati i motori, tuttavia, si sono determinati dei
giochi meccanici non trascurabili tra il movimento dei rotori e lo spostamento
effettivo del Robot sulla scacchiera, che avrebbero causato errori di
posizionamento superiori alla lunghezza di mezza casella.\\
La classe \texttt{LashMotor} estende l'API \texttt{Motor} di \emph{Lejos} e
rappresenta un motore in grado di recuperare un gioco costante (che deve quindi
essere preventivamente stimato\footnote{La stima dei giochi è stata effettuata
empiricamente cercando di determinare l'angolo minimo tale da indurre un
movimento del Robot, in seguito a un cambio di verso di rotazione.}) in modo
trasparente all'utilizzatore.\\
Il metodo reimplementato in \texttt{LashMotor} è \texttt{rotateTo()}: il
recupero del gioco avviene solo quando si verifica un'inversione (si è scelto
il verso negativo perchè si richiede che i motori vengano inizializzati con
gioco nullo nel verso positivo, ad esempio a fine calibrazione) semplicemente
decrementando l'angolo di destinazione della costante \texttt{lash} stimata.\\
\begin{lstlisting}
	public void rotateTo(int limitAngle, boolean nonBlocking) {
		if (limitAngle < super.getTachoCount())
			limitAngle -= lash;
		super.rotateTo(limitAngle, nonBlocking);
	}
\end{lstlisting}
Si noti che, nel caso di cambio di direzione inverso, il recupero avviene senza
bisogno di modificare l'angolo di destinazione infatti, detti $c$ la costante
\texttt{lash} e $\theta_0$ l'angolo di partenza si avrebbe:
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=0.7]{img/lashMotor.png}
		\caption{Recupero dei giochi in un motore LashMotor \label{lashMotor}}
	\end{center}
\end{figure} 
\itemize
\item Rotazione all'angolo $\theta_1 < \theta_0$
	$$\theta = \theta_0 + (\theta_1 - \theta_0 - c) = \theta_1 - c$$
\item Rotazione all'angolo $\theta_2 > \theta_1$
	$$\theta = \theta_1 - c + (\theta_2 - (\theta_1 - c)) = \theta_2$$

\section{L'interfaccia  CheckersNavigator}
Questa interfaccia astrae le funzionalità di movimento bidimensionale sulla scacchiera 8x8; i metodi più importanti sono:

\begin{lstlisting}
/** Ritorna la posizione X [0; 7] */
public int getX(); 
/** Ritorna la posizione Y [0; 7] */
public int getY(); 
/** Muove il braccio sulla casella (X, Y) */
public void goTo(int newX, int newY) throws NotCalibratedException; 
/** Muove il braccio sulla casella "base" */
public void goHome() throws NotCalibratedException; 
/** Modifica la velocità dei motori */
public void setSpeed(int speedA, int speedB);
/** Effettua la calibrazione */
public void calibrate();
\end{lstlisting}
Si noti come i metodi che comportano un movimento non possano essere eseguiti se prima non è stata effettuata la calibrazione (eccezione \texttt{NotCalibrated\-Exception}).\\
Esamineremo ora le implementazioni che sono state progettate per questa interfaccia.

\subsection{La classe SimpleNavigator}
Questa prima implementazione si basa su un mapping statico di tutte le caselle relativo ad un punto iniziale su cui il Robot tenta di posizionarsi in fase di calibrazione.

\paragraph{Calibrazione}
Il Robot, per come è costruito, può ruotare il suo braccio agendo sul motore B, o può spostarlo avanti e indietro agendo sul motore A.\\
Il primo metodo di calibrazione che è stato pensato è pertanto semplicemente mirato a portare il braccio in una posizione nota (punto rosso in Figura \ref{simpleNavigatorGrid}), in modo da poter usare offset predeterminati (relativi ad essa) per spostarlo su tutte le altre caselle. \\
\begin{figure}[h]
\begin{center}
\includegraphics{img/simpleNavigatorGrid.jpg}
\caption{Scacchiera SimpleNavigator \label{simpleNavigatorGrid}}
\end{center}
\end{figure}
Il metodo \texttt{calibrate()} non fa altro che ruotare il braccio verso destra finché il sensore di colore montato su di esso non rileva il colore rosso, a quel punto recupera eventuali giochi dei motori e azzera i contatori di distanza angolare in essi contenuti.

\paragraph{Navigazione}
Gli angoli di destinazione cui vengono fatti ruotare i motori sono calcolati semplicemente come\footnote{X e Y sono rispettivamente le  coordinate di ascissa e di ordinata delle caselle}: 
\begin{lstlisting}
destAngleA = offA+posy[newY]+dely[newX];
destAngleB = offB+posx[newX];
\end{lstlisting}
I vettori \texttt{posx} e \texttt{posy} definiscono l'offset in funzione delle rispettive coordinate; il vettore \texttt{dely} contiene le correzioni da effettuare sull'asse y in funzione della coordinata x, in modo da recuperare gli scostamenti in verticale dati dal fatto che il braccio si muove su un arco di circonferenza.\\
Le costanti \texttt{offA} e \texttt{offB} definiscono invece l'offset necessario a portare il braccio sulla casella (5,0) che costituiva il punto più comodo cui riferire la taratura di tutte le altre caselle.

\subsection{La classe MathNavigator}
\paragraph{Calibrazione}
\paragraph{Navigazione}

\section{La classe ArmController}
